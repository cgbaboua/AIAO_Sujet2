# -*- coding: utf-8 -*-
"""ACP_Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h6n10hN4oARySDGodiOFM-9O30JWM-K-
"""

# Ouverture du data

"""# Nouvelle section"""

import pandas as pd
import numpy as np
import sklearn
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull
import os
import requests
import matplotlib as mpl
import matplotlib.cm as cm
from tqdm.auto import tqdm
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, roc_curve
import seaborn as sns
import plotly.express as px

#######################################
# biplot
# version 12/11/2021
#######################################
def biplot(pca=[],x=None,y=None,components=[0,1],score=None,coeff=None,coeff_labels=None,score_labels=None,circle='T',bigdata=1000,cat=None,cmap="viridis",density=True):
    if isinstance(pca,PCA)==True :
        coeff = np.transpose(pca.components_[components, :])
        score=  pca.fit_transform(x)[:,components]
        if isinstance(x,pd.DataFrame)==True :
            coeff_labels = list(x.columns)
    if score is not None : x = score
    if x.shape[1]>1 :
        xs = x[:,0]
        ys = x[:,1]
    else :
        xs = x
        ys = y
    if (len(xs) != len(ys)) : print("Warning ! x et y n'ont pas la même taille !")
    scalex = 1.0/(xs.max() - xs.min())
    scaley = 1.0/(ys.max() - ys.min())
    #x_c = xs * scalex
    #y_c = ys * scaley
    temp = (xs - xs.min())
    x_c = temp / temp.max() * 2 - 1
    temp = (ys - ys.min())
    y_c = temp / temp.max() * 2 - 1
    data = pd.DataFrame({"x_c":x_c,"y_c":y_c})
    print("Attention : pour des facilités d'affichage, les données sont centrées-réduites")
    if cat is None : cat = [0]*len(xs)
    elif len(pd.Series(cat)) == 1 : cat = list(pd.Series(cat))*len(xs)
    elif len(pd.Series(cat)) != len(xs) : print("Warning ! Nombre anormal de catégories !")
    cat = pd.Series(cat).astype("category")
    fig = plt.figure(figsize=(6,6),facecolor='w')
    ax = fig.add_subplot(111)
    # Affichage des points
    if (len(xs) < bigdata) :
        ax.scatter(x_c,y_c, c = cat.cat.codes,cmap=cmap)
        if density==True : print("Warning ! Le mode density actif n'apparait que si BigData est paramétré.")
    # Affichage des nappes convexes (BigData)
    else :
        #color
        norm = mpl.colors.Normalize(vmin=0, vmax=(len(np.unique(cat.cat.codes)))) #-(len(np.unique(c)))
        cmap = cmap
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        if density==True :
            sns.set_style("white")
            sns.kdeplot(x="x_c",y="y_c",data=data)
            if len(np.unique(cat)) <= 1 :
                sns.kdeplot(x="x_c",y="y_c",data=data, cmap="Blues", shade=True, thresh= 0)
            else :
                for i in np.unique(cat) :
                    color_temp = m.to_rgba(i)
                    sns.kdeplot(x="x_c",y="y_c",data=data[cat==i], color=color_temp,
                                shade=True, thresh=0.25, alpha=0.25)
        for cat_temp in cat.cat.codes.unique() :
            x_c_temp = [x_c[i] for i in range(len(x_c)) if (cat.cat.codes[i] == cat_temp)]
            y_c_temp = [y_c[i] for i in range(len(y_c)) if (cat.cat.codes[i] == cat_temp)]
            points = [ [ None ] * len(x_c_temp) ] * 2
            points = np.array(points)
            points = points.reshape(len(x_c_temp),2)
            points[:,0] = x_c_temp
            points[:,1] = y_c_temp
            hull = ConvexHull(points)
            temp = 0
            for simplex in hull.simplices:
                color_temp = m.to_rgba(cat_temp)
                plt.plot(points[simplex, 0], points[simplex, 1],color=color_temp)#, linestyle='dashed')#linewidth=2,color=cat)
                if (temp == 0) :
                     plt.xlim(-1,1)
                     plt.ylim(-1,1)
                     temp = temp+1
    if coeff is not None :
        if (circle == 'T') :
            x_circle = np.linspace(-1, 1, 100)
            y_circle = np.linspace(-1, 1, 100)
            X, Y = np.meshgrid(x_circle,y_circle)
            F = X**2 + Y**2 - 1.0
            #fig, ax = plt.subplots()
            plt.contour(X,Y,F,[0])
        n = coeff.shape[0]
        for i in range(n):
            plt.arrow(0, 0, coeff[i,0], coeff[i,1],color = 'r',alpha = 0.5,
                      head_width=0.05, head_length=0.05)
            if coeff_labels is None:
                plt.text(coeff[i,0]* 1.15, coeff[i,1] * 1.15, "Var"+str(i+1), color = 'g', ha = 'center', va = 'center')
            else:
                plt.text(coeff[i,0]* 1.15, coeff[i,1] * 1.15, coeff_labels[i], color = 'g', ha = 'center', va = 'center')
        if score_labels is not None :
            for i in range(len(score_labels)) :
                temp_x = xs[i] * scalex
                temp_y = ys[i] * scaley
                plt.text(temp_x,temp_y,list(score_labels)[i])
    plt.xlim(-1.2,1.2)
    plt.ylim(-1.2,1.2)
    plt.xlabel("PC{}".format(1))
    plt.ylabel("PC{}".format(2))
    plt.grid(linestyle='--')
    plt.show()

from google.colab import drive
drive.mount('/content/drive')

train_data = pd.read_pickle('/content/drive/MyDrive/AIAO_Kaggle/Data/train_series_preprocessed_moi.parquet')
#train_data = train_data[9989:13989]
train_data

# Sélection des variables indépendantes
X = train_data[['anglez', 'enmo']]
X

# Variable dépendante (binaire)
Y = train_data['event']

Y_binary = np.zeros(len(Y))
Y_binary[Y == 'wakeup'] = 1
Y = Y_binary
print(Y)

len(Y)

"""Mise à l'échelle des données"""

# Mise à l'échelle
scaler = StandardScaler()
#X = scaler.fit_transform(X)
scaler.fit(X)
X=scaler.transform(X)


# Affichage avec boxplot
plt.boxplot(X, labels=['anglez', 'enmo'])
plt.title("Données mises à l'échelle")
plt.xlabel("Variables")
plt.ylabel("Valeurs mises à l'échelle")
plt.show()



X

pca = PCA(n_components=2) # On paramètre ici pour ne garder que 2 composantes
# Modèle d'ACP
pca.fit(X)
principalcp = pca.fit_transform(X)
# Pourcentage de la variance expliquée par chacune des composantes sélectionnées.
print(pca.explained_variance_) # Valeurs de variance
print(pca.explained_variance_ratio_) #  Pourcentages

# Créer le biplot
def make_biplot(principalComponents, pca, feature_labels):
    plt.figure(figsize=(10, 6))

    # Tracer les points
    plt.scatter(principalComponents[:, 0], principalComponents[:, 1], edgecolors='k', c=y)

    # Tracer les vecteurs des variables
    for i, (x, y) in enumerate(zip(pca.components_[0], pca.components_[1])):
        plt.arrow(0, 0, x * 3, y * 3, fc='r', ec='r', head_width=0.1, head_length=0.1)
        plt.text(x * 3.5, y * 3.5, feature_labels[i], color='r')

    plt.xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}%)')
    plt.ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}%)')
    plt.title('Biplot')
    plt.grid(True)
    plt.show()

make_biplot(principalcp, pca, ['enmo', 'anglez'],Y)

#Mise ne place de l'ACP
pca = PCA(n_components=2) # Ici, on réduit à 2 composantes pour la visualisation
# Exécution de l'ACP
principalComponents = pca.fit_transform(X)

# Conversion en DataFrame pour la visualisation
principalDf = pd.DataFrame(data=principalComponents, columns=['PC1', 'PC2'])

# Visualisation
plt.figure(figsize=(8, 6))
plt.scatter(principalDf['PC1'], principalDf['PC2'])
plt.xlabel('Première composante principale')
plt.ylabel('Deuxième composante principale')
plt.title('Représentation 2D de l\'ACP')
plt.show()

# Affichage des résultats
plt.figure(figsize=(8,6))
plt.scatter(pca[:,0], pca[:,1])
plt.xlabel('Première composante principale')
plt.ylabel('Deuxième composante principale')
plt.show()

explained_variance = pca.explained_variance_ratio_
print(f"Variance expliquée par la première composante : {explained_variance[0]*100:.2f}%")
print(f"Variance expliquée par la deuxième composante : {explained_variance[1]*100:.2f}%")

reducer = umap.UMAP()
embedding = reducer.fit_transform(X)

# Tracer le résultat
plt.scatter(embedding[:, 0], embedding[:, 1],c=Y, cmap='rainbow')
plt.title('UMAP')
plt.xlabel('UMAP1')
plt.ylabel('UMAP2')
plt.show()